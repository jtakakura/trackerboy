
#include "trackerboy/synth/Osc.hpp"
#include "trackerboy/gbs.hpp"

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstddef>

//
// TODO: replace PulseChannel and WaveChannel step methods with this
//


namespace trackerboy {

const float Osc::STEP_TABLE[Osc::STEP_PHASES][Osc::STEP_WIDTH] = {
    // this table was generated by genstep.py
    // genstep.py 48000 64 32 16
    /* Phase:  0.000 */    { -0.003784475f, -0.003535828f,  0.004340462f, -0.005829123f,  0.009078607f, -0.018622857f,  0.078168809f,  0.878319860f,  0.076119840f, -0.018622857f,  0.009078607f, -0.005829123f,  0.004340462f, -0.003535828f,  0.003052017f, -0.002738550f },
    /* Phase: -0.031 */    { -0.005327771f, -0.000169666f,  0.000291439f, -0.000744221f,  0.002225769f, -0.008001324f,  0.052062213f,  0.877660334f,  0.104194060f, -0.029417379f,  0.015990680f, -0.010938583f,  0.008398815f, -0.006903260f,  0.005929855f, -0.005250984f },
    /* Phase: -0.062 */    { -0.006857183f,  0.003163166f, -0.003709834f,  0.004268206f, -0.004504234f,  0.002353548f,  0.027424902f,  0.874504030f,  0.133539170f, -0.040286299f,  0.022896413f, -0.016023669f,  0.012427498f, -0.010239549f,  0.008776450f, -0.007732605f },
    /* Phase: -0.094 */    { -0.008358261f,  0.006431256f, -0.007625873f,  0.009161680f, -0.011050299f,  0.012353589f,  0.004336254f,  0.868865550f,  0.164039060f, -0.051126759f,  0.029728813f, -0.021034885f,  0.016387289f, -0.013512234f,  0.011564126f, -0.010159300f },
    /* Phase: -0.125 */    { -0.009816961f,  0.009604135f, -0.011420466f,  0.013891567f, -0.017354323f,  0.021916678f, -0.017135506f,  0.860773146f,  0.195568398f, -0.061832327f,  0.036420058f, -0.025922617f,  0.020239117f, -0.016689116f,  0.014265519f, -0.012507295f },
    /* Phase: -0.156 */    { -0.011219775f,  0.012652548f, -0.015058996f,  0.018415462f, -0.023361657f,  0.030967221f, -0.036933571f,  0.850268304f,  0.227993354f, -0.072293706f,  0.042902090f, -0.030637598f,  0.023944430f, -0.019738562f,  0.016853841f, -0.014753380f },
    /* Phase: -0.188 */    { -0.012553850f,  0.015548721f, -0.018508749f,  0.022693552f, -0.029021539f,  0.039436568f, -0.055012733f,  0.837405682f,  0.261172295f, -0.082399532f,  0.049107224f, -0.035131380f,  0.027465567f, -0.022629824f,  0.019303137f, -0.016875131f },
    /* Phase: -0.219 */    { -0.013807107f,  0.018266609f, -0.021739192f,  0.026688935f, -0.034287456f,  0.047263388f, -0.071339481f,  0.822252572f,  0.294956684f, -0.092037149f,  0.054968778f, -0.039356798f,  0.030766128f, -0.025333321f,  0.021588551f, -0.018851142f },
    /* Phase: -0.250 */    { -0.014968345f,  0.020782117f, -0.024722239f,  0.030367931f, -0.039117496f,  0.054393932f, -0.085892022f,  0.804888606f,  0.329191953f, -0.101093441f,  0.060421702f, -0.043268427f,  0.033811335f, -0.027820952f,  0.023686554f, -0.020661226f },
    /* Phase: -0.281 */    { -0.016027341f,  0.023073314f, -0.027432477f,  0.033700336f, -0.043474626f,  0.060782306f, -0.098660186f,  0.785405278f,  0.363718361f, -0.109455675f,  0.065403208f, -0.046823047f,  0.036568381f, -0.030066375f,  0.025575206f, -0.022286622f },
    /* Phase: -0.312 */    { -0.016974937f,  0.025120620f, -0.029847380f,  0.036659647f, -0.047326934f,  0.066390589f, -0.109645329f,  0.763905048f,  0.398372054f, -0.117012337f,  0.069853365f, -0.049980074f,  0.039006766f, -0.032045264f,  0.027234353f, -0.023710191f },
    /* Phase: -0.344 */    { -0.017803114f,  0.026906956f, -0.031947475f,  0.039223265f, -0.050647821f,  0.071188956f, -0.118860044f,  0.740501225f,  0.432986021f, -0.123654038f,  0.073715761f, -0.052701995f,  0.041098613f, -0.033735584f,  0.028645860f, -0.024916582f },
    /* Phase: -0.375 */    { -0.018505065f,  0.028417893f, -0.033716507f,  0.041372646f, -0.053416137f,  0.075155690f, -0.126327932f,  0.715316713f,  0.467391223f, -0.129274324f,  0.076938018f, -0.054954760f,  0.042818982f, -0.035117805f,  0.029793786f, -0.025892405f },
    /* Phase: -0.406 */    { -0.019075235f,  0.029641751f, -0.035141528f,  0.043093402f, -0.055616271f,  0.078277171f, -0.132083133f,  0.688483417f,  0.501417518f, -0.133770570f,  0.079472445f, -0.056708165f,  0.044146121f, -0.036175124f,  0.030664563f, -0.026626363f },
    /* Phase: -0.438 */    { -0.019509381f,  0.030569695f, -0.036212999f,  0.044375382f, -0.057238191f,  0.080547750f, -0.136169970f,  0.660141647f,  0.534894705f, -0.137044802f,  0.081276514f, -0.057936206f,  0.045061741f, -0.036893670f,  0.031247150f, -0.027109390f },
    /* Phase: -0.469 */    { -0.019804578f,  0.031195775f, -0.036924843f,  0.045212720f, -0.058277428f,  0.081969582f, -0.138642401f,  0.630438685f,  0.567653954f, -0.139004499f,  0.082313396f, -0.058617391f,  0.045551222f, -0.037262633f,  0.031533163f, -0.027334746f },
    /* Phase: -0.500 */    { -0.019959260f,  0.031516965f, -0.037274439f,  0.045603793f, -0.058735020f,  0.082552440f, -0.139563426f,  0.599528372f,  0.599528372f, -0.139563426f,  0.082552440f, -0.058735020f,  0.045603793f, -0.037274439f,  0.031516965f, -0.027298102f },
    /* Phase: -0.531 */    { -0.019973196f,  0.031533163f, -0.037262633f,  0.045551222f, -0.058617391f,  0.082313396f, -0.139004499f,  0.567569673f,  0.630354464f, -0.138642401f,  0.081969582f, -0.058277428f,  0.045212720f, -0.036924843f,  0.031195775f, -0.026997609f },
    /* Phase: -0.562 */    { -0.019847505f,  0.031247150f, -0.036893670f,  0.045061741f, -0.057936206f,  0.081276514f, -0.137044802f,  0.534726083f,  0.659972966f, -0.136169970f,  0.080547750f, -0.057238191f,  0.044375382f, -0.036212999f,  0.030569695f, -0.026433926f },
    /* Phase: -0.594 */    { -0.019584613f,  0.030664563f, -0.036175124f,  0.044146121f, -0.056708165f,  0.079472445f, -0.133770570f,  0.501164138f,  0.688230097f, -0.132083133f,  0.078277171f, -0.055616271f,  0.043093402f, -0.035141528f,  0.029641751f, -0.025610242f },
    /* Phase: -0.625 */    { -0.019188233f,  0.029793786f, -0.035117805f,  0.042818982f, -0.054954760f,  0.076938018f, -0.129274324f,  0.467052728f,  0.714978218f, -0.126327932f,  0.075155690f, -0.053416137f,  0.041372646f, -0.033716507f,  0.028417893f, -0.024532266f },
    /* Phase: -0.656 */    { -0.018663315f,  0.028645860f, -0.033735584f,  0.041098613f, -0.052701995f,  0.073715761f, -0.123654038f,  0.432561934f,  0.740077138f, -0.118860044f,  0.071188956f, -0.050647821f,  0.039223265f, -0.031947475f,  0.026906956f, -0.023208190f },
    /* Phase: -0.688 */    { -0.018015981f,  0.027234353f, -0.032045264f,  0.039006766f, -0.049980074f,  0.069853365f, -0.117012337f,  0.397861779f,  0.763394833f, -0.109645329f,  0.066390589f, -0.047326934f,  0.036659647f, -0.029847380f,  0.025120620f, -0.021648636f },
    /* Phase: -0.719 */    { -0.017253468f,  0.025575206f, -0.030066375f,  0.036568381f, -0.046823047f,  0.065403208f, -0.109455675f,  0.363121390f,  0.784808278f, -0.098660186f,  0.060782306f, -0.043474626f,  0.033700336f, -0.027432477f,  0.023073314f, -0.019866575f },
    /* Phase: -0.750 */    { -0.016384043f,  0.023686554f, -0.027820952f,  0.033811335f, -0.043268427f,  0.060421702f, -0.101093441f,  0.328507781f,  0.804204464f, -0.085892022f,  0.054393932f, -0.039117496f,  0.030367931f, -0.024722239f,  0.020782117f, -0.017877219f },
    /* Phase: -0.781 */    { -0.015416916f,  0.021588551f, -0.025333321f,  0.030766128f, -0.039356798f,  0.054968778f, -0.092037149f,  0.294184983f,  0.821480870f, -0.071339481f,  0.047263388f, -0.034287456f,  0.026688935f, -0.021739192f,  0.018266609f, -0.015697902f },
    /* Phase: -0.812 */    { -0.014362147f,  0.019303137f, -0.022629824f,  0.027465567f, -0.035131380f,  0.049107224f, -0.082399532f,  0.260312825f,  0.836546242f, -0.055012733f,  0.039436568f, -0.029021539f,  0.022693552f, -0.018508749f,  0.015548721f, -0.013347929f },
    /* Phase: -0.844 */    { -0.013230545f,  0.016853841f, -0.019738562f,  0.023944430f, -0.030637598f,  0.042902090f, -0.072293706f,  0.227046251f,  0.849321187f, -0.036933571f,  0.030967221f, -0.023361657f,  0.018415462f, -0.015058996f,  0.012652548f, -0.010848409f },
    /* Phase: -0.875 */    { -0.012033555f,  0.014265519f, -0.016689116f,  0.020239117f, -0.025922617f,  0.036420058f, -0.061832327f,  0.194534078f,  0.859738827f, -0.017135506f,  0.021916678f, -0.017354323f,  0.013891567f, -0.011420466f,  0.009604135f, -0.008222071f },
    /* Phase: -0.906 */    { -0.010783146f,  0.011564126f, -0.013512234f,  0.016387289f, -0.021034885f,  0.029728813f, -0.051126759f,  0.162918374f,  0.867744863f,  0.004336254f,  0.012353589f, -0.011050299f,  0.009161680f, -0.007625873f,  0.006431256f, -0.005493056f },
    /* Phase: -0.938 */    { -0.009491698f,  0.008776450f, -0.010239549f,  0.012427498f, -0.016023669f,  0.022896413f, -0.040286299f,  0.132333472f,  0.873298347f,  0.027424902f,  0.002353548f, -0.004504234f,  0.004268206f, -0.003709834f,  0.003163166f, -0.002686710f },
    /* Phase: -0.969 */    { -0.008171870f,  0.005929855f, -0.006903260f,  0.008398815f, -0.010938583f,  0.015990680f, -0.029417379f,  0.102905288f,  0.876371562f,  0.052062213f, -0.008001324f,  0.002225769f, -0.000744221f,  0.000291439f, -0.000169666f,  0.000170660f }
};

const float Osc::VOLUME_TABLE[16] = {
    0.0f,
    1 * VOLUME_STEP,
    2 * VOLUME_STEP,
    3 * VOLUME_STEP,
    4 * VOLUME_STEP,
    5 * VOLUME_STEP,
    6 * VOLUME_STEP,
    7 * VOLUME_STEP,
    8 * VOLUME_STEP,
    9 * VOLUME_STEP,
    10 * VOLUME_STEP,
    11 * VOLUME_STEP,
    12 * VOLUME_STEP,
    13 * VOLUME_STEP,
    14 * VOLUME_STEP,
    VOLUME_MAX
};


// Public methods ------------------------------------------------------------

uint16_t Osc::frequency() {
    return mFrequency;
}

void Osc::generate(float buf[], size_t nsamples) {
    // first, clear the output buffer
    std::fill_n(buf, nsamples, 0.0f);

    // generate samples if the waveform is not flat and we aren't muted
    // and the frequency is below or equal to the nyquist frequency
    if (!mMuted && mDeltaBuf.size() > 0 && mFrequency <= mNyquist) {

        auto deltaEnd = mDeltaBuf.end();

        if (mRecalc) {
            // frequency and/or waveform changed, recalculate deltas
            mSamplesPerDelta = (2048 - mFrequency) * mMultiplier * mFactor;
            mSamplesPerPeriod = mSamplesPerDelta * mWaveformSize;

            resetPeriod();

            mRecalc = false;
        } else {
            // we are continuing the existing waveform,
            // copy the leftovers to the start
            std::copy_n(mLeftovers, STEP_WIDTH - 1, buf);
        }
        // clear the leftover buffer
        std::fill_n(mLeftovers, STEP_WIDTH - 1, 0.0f);

        // add the transitions (sinc sets)

        // add steps for each delta until this limit is reached
        const size_t limit = nsamples + STEP_CENTER;
        // when a center of transition exceeds this limit, the transition is outside of the output buffer
        // (which will be the first transition to generate on the next call)
        for (auto iter = mDeltaBuf.begin(); iter != deltaEnd; ++iter) {
            // cache these values
            float position = iter->position; // this is the location in the buffer, in samples, of the current transition 
            float change = iter->change;

            while (position < limit) {

                float positionWhole;
                float positionFract = modff(position, &positionWhole);
                // index of the center of the step
                size_t centerIndex = static_cast<size_t>(positionWhole);
                // the sinc set chosen is determined by the fractional part of position
                float phase = positionFract * STEP_PHASES;

                const float *sincset = STEP_TABLE[static_cast<size_t>(phase)];

                // ending index of the band limited step
                size_t endIndex = centerIndex + (STEP_WIDTH - STEP_CENTER);

                // determine the range of the set to use
                size_t sincStart;
                size_t sincEnd;
                float *dest = buf;

                if (centerIndex < STEP_CENTER) {
                    // we are at the start of the buffer
                    sincStart = STEP_CENTER - centerIndex;
                } else {
                    // we are somewhere in between
                    sincStart = 0;
                    // point dest to the start of the step
                    dest += centerIndex - STEP_CENTER;
                }

                if (endIndex > nsamples) {
                    // we are at the end of the buffer
                    sincEnd = STEP_WIDTH - (endIndex - nsamples);
                } else {
                    sincEnd = STEP_WIDTH;
                }

                // copy to the buffer
                float error = change;  // precision error
                for (size_t i = sincStart; i != sincEnd; ++i) {
                    float sample = change * sincset[i];
                    error -= sample;
                    *dest++ += sample;
                }

                // copy to leftovers (if needed)
                dest = mLeftovers;
                for (size_t i = sincEnd; i != STEP_WIDTH; ++i) {
                    float sample = change * sincset[i];
                    error -= sample;
                    *dest++ += sample;
                }

                // add the error so that the sum of the step is equal to change
                // (this error comes from taking the floor of a sample in the step)
                if (centerIndex >= nsamples) {
                    mLeftovers[centerIndex - nsamples] += error;
                } else {
                    buf[centerIndex] += error;
                }


                // next period
                position += mSamplesPerPeriod;
            }

            iter->position = position - nsamples;

        }

        // do the running sum
        for (size_t i = 0; i != nsamples; ++i) {
            *buf += mPrevious;
            mPrevious = *buf++;
            //assert(mPrevious <= 1.0f && mPrevious >= -1.0f);
        }

    }

}

bool Osc::muted() {
    return mMuted;
}

float Osc::outputFrequency() {
    // period of the oscilator is (2048 - mFrequency) * multiplier * waveformSize
    // example ranges (multiplier, waveformSize)
    // PulseOsc: (4, 8):    64 Hz - 131,072 Hz
    // WaveOsc: (2, 32):    32 Hz - 65,536 Hz
    return Gbs::CLOCK_SPEED / ((2048 - mFrequency) * mMultiplier * mWaveformSize);
}

void Osc::reset() {
    // just reset the period if the frequency/waveform is unchanged
    if (!mRecalc) {
        resetPeriod();
    }
}

void Osc::setFrequency(uint16_t frequency) {
    mFrequency = frequency;
    mRecalc = true;
}


void Osc::setMute(bool muted) {
    mMuted = muted;
}


// protected methods ---------------------------------------------------------


Osc::Osc(float samplingRate, size_t multiplier, size_t waveformSize) :
    mMultiplier(multiplier),
    mWaveformSize(waveformSize),
    mFactor(samplingRate / Gbs::CLOCK_SPEED),
    mFrequency(Gbs::DEFAULT_FREQUENCY),
    mRecalc(true),
    mSamplesPerDelta(0.0f),
    mSamplesPerPeriod(0.0f),
    mPrevious(0),
    mLeftovers{ 0 },
    mDeltaBuf(),
    mMuted(false)
{
    // assert that waveform size is a power of 2
    assert((mWaveformSize & (mWaveformSize - 1)) == 0);

    float nyquist = samplingRate * 0.5f;
    mNyquist = static_cast<uint16_t>(2048 - Gbs::CLOCK_SPEED / (nyquist * multiplier * waveformSize));

}

void Osc::resetPeriod() {
    // calculate initial positions
    for (auto iter = mDeltaBuf.begin(); iter != mDeltaBuf.end(); ++iter) {
        iter->position = iter->location * mSamplesPerDelta;
    }

    // initialize previous with the starting sample of the waveform
    mPrevious = mDeltaBuf[0].before;
}

}

#include "trackerboy/synth/Osc.hpp"
#include "trackerboy/gbs.hpp"
#include "./sampletable.hpp"

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstddef>

//
// TODO: replace PulseChannel and WaveChannel step methods with this
//

namespace trackerboy {

//
// Sinc table
// this table contains sets of normalized sinc lookup tables
// each set has a different phase (0 to -1). First set has a phase of -1/m
// and the last set has a phase of -(m - 1)/m, where m is SINC_PHASES * 2
// see https://www.desmos.com/calculator/w0rh8oarmu for how these values were chosen.
// When generating a band-limited step, the fractional part of the delta's location in the
// waveform is used to pick the set (phase).
//
// using this we can create bandlimited steps by multiplying each value in a step by
// the delta change and then do a running sum.
//
// This table was generated by gensinc.py
//
const float Osc::SINC_TABLE[Osc::SINC_PHASES][Osc::SINC_STEPS] = {
   ///* Phase: -0.031 */    { -0.004437308f, 0.005173028f, -0.006201208f, 0.007739491f, -0.010292726f, 0.015359914f, -0.030254375f, 0.998377264f, 0.032206271f, -0.015847530f, 0.010509415f, -0.007861373f, 0.006279210f, -0.005227196f, 0.004477105f },
   // /* Phase: -0.062 */    { -0.008792804f, 0.010243163f, -0.012266505f, 0.015285952f, -0.020277282f, 0.030108692f, -0.058446284f, 0.993518710f, 0.066239126f, -0.032051187f, 0.021140145f, -0.015771220f, 0.012577049f, -0.010458809f, 0.008951233f },
   // /* Phase: -0.094 */    { -0.013025619f, 0.015163156f, -0.018139971f, 0.022571111f, -0.029866822f, 0.044131573f, -0.084480442f, 0.985453129f, 0.101959154f, -0.048472386f, 0.031793714f, -0.023654524f, 0.018833220f, -0.015644526f, 0.013379255f },
   // /* Phase: -0.125 */    { -0.017096410f, 0.019887660f, -0.023768179f, 0.029530162f, -0.038979813f, 0.057323255f, -0.108277261f, 0.974228084f, 0.139213622f, -0.064966358f, 0.042369362f, -0.031435333f, 0.024987061f, -0.020733943f, 0.017718097f },
   // /* Phase: -0.156 */    { -0.020967720f, 0.024373643f, -0.029100653f, 0.036102314f, -0.047540672f, 0.069588520f, -0.129773185f, 0.959909916f, 0.177837327f, -0.081383184f, 0.052764919f, -0.039037462f, 0.030978115f, -0.025677046f, 0.021925149f },
   // /* Phase: -0.188 */    { -0.024604313f, 0.028580768f, -0.034090314f, 0.042231284f, -0.055480313f, 0.080842741f, -0.148920834f, 0.942583084f, 0.217653543f, -0.097568825f, 0.062877685f, -0.046385180f, 0.036746699f, -0.030424688f, 0.025958678f },
   // /* Phase: -0.219 */    { -0.027973494f, 0.032471742f, -0.038693875f, 0.047865756f, -0.062736668f, 0.091012351f, -0.165689155f, 0.922349453f, 0.258475065f, -0.113366261f, 0.072605357f, -0.053403940f, 0.042234492f, -0.034929063f, 0.029778235f },
   // /* Phase: -0.250 */    { -0.031045390f, 0.036012653f, -0.042872205f, 0.052959785f, -0.069255099f, 0.100035146f, -0.180063263f, 0.899327755f, 0.300105453f, -0.128616616f, 0.081846938f, -0.060021088f, 0.047385070f, -0.039144188f, 0.033345047f },
   // /* Phase: -0.281 */    { -0.033793218f, 0.039173234f, -0.046590649f, 0.057473138f, -0.074988760f, 0.107860543f, -0.192044392f, 0.873652756f, 0.342339993f, -0.143160358f, 0.090503678f, -0.066166550f, 0.052144501f, -0.043026339f, 0.036622416f },
   // /* Phase: -0.312 */    { -0.036193505f, 0.041927129f, -0.049819294f, 0.061371595f, -0.079898864f, 0.114449732f, -0.201649517f, 0.845474124f, 0.384967268f, -0.156838521f, 0.098480001f, -0.071773559f, 0.056461867f, -0.046534505f, 0.039576076f },
   // /* Phase: -0.344 */    { -0.038226280f, 0.044252101f, -0.052533194f, 0.064627171f, -0.083954915f, 0.119775683f, -0.208911076f, 0.814955473f, 0.427770287f, -0.169493884f, 0.105684429f, -0.076779284f, 0.060289774f, -0.049630810f, 0.042174537f },
   // /* Phase: -0.375 */    { -0.039875254f, 0.046130195f, -0.054712556f, 0.067218281f, -0.087134808f, 0.123823151f, -0.213876352f, 0.782273293f, 0.470527977f, -0.180972308f, 0.112030469f, -0.081125513f, 0.063584864f, -0.052280888f, 0.044389430f },
   // /* Phase: -0.406 */    { -0.041127909f, 0.047547873f, -0.056342855f, 0.069129892f, -0.089424901f, 0.126588494f, -0.216606990f, 0.747615576f, 0.513016522f, -0.191123813f, 0.117437519f, -0.084759258f, 0.066308260f, -0.054454271f, 0.046195801f },
   // /* Phase: -0.438 */    { -0.041975617f, 0.048496101f, -0.057414923f, 0.070353501f, -0.090819970f, 0.128079444f, -0.217178196f, 0.711180627f, 0.555010915f, -0.199803934f, 0.121831670f, -0.087633304f, 0.068426006f, -0.056124702f, 0.047572367f },
   // /* Phase: -0.469 */    { -0.042413674f, 0.048970379f, -0.057924964f, 0.070887193f, -0.091323137f, 0.128314793f, -0.215678051f, 0.673175454f, 0.596286356f, -0.206874862f, 0.125146523f, -0.089706801f, 0.069909438f, -0.057270441f, 0.048501763f },
   // /* Phase: -0.500 */    { -0.042441320f, 0.048970751f, -0.057874523f, 0.070735529f, -0.090945683f, 0.127323955f, -0.212206587f, 0.633814692f, 0.636619747f, -0.212206587f, 0.127323955f, -0.090945683f, 0.070735529f, -0.057874523f, 0.048970751f },
   // /* Phase: -0.531 */    { -0.042061694f, 0.048501763f, -0.057270441f, 0.069909438f, -0.089706801f, 0.125146523f, -0.206874862f, 0.593318641f, 0.675791204f, -0.215678051f, 0.128314793f, -0.091323137f, 0.070887193f, -0.057924964f, 0.048970379f },
   // /* Phase: -0.562 */    { -0.041281804f, 0.047572367f, -0.056124702f, 0.068426006f, -0.087633304f, 0.121831670f, -0.199803934f, 0.551912248f, 0.713585496f, -0.217178196f, 0.128079444f, -0.090819970f, 0.070353501f, -0.057414923f, 0.048496101f },
   // /* Phase: -0.594 */    { -0.040112406f, 0.046195801f, -0.054454271f, 0.066308260f, -0.084759258f, 0.117437519f, -0.191123813f, 0.509823263f, 0.749793410f, -0.216606990f, 0.126588494f, -0.089424901f, 0.069129892f, -0.056342855f, 0.047547873f },
   // /* Phase: -0.625 */    { -0.038567867f, 0.044389430f, -0.052280888f, 0.063584864f, -0.081125513f, 0.112030469f, -0.180972308f, 0.467280596f, 0.784213305f, -0.213876352f, 0.123823151f, -0.087134808f, 0.067218281f, -0.054712556f, 0.046130195f },
   // /* Phase: -0.656 */    { -0.036666024f, 0.042174537f, -0.049630810f, 0.060289774f, -0.076779284f, 0.105684429f, -0.169493884f, 0.424513131f, 0.816652358f, -0.208911076f, 0.119775683f, -0.083954915f, 0.064627171f, -0.052533194f, 0.044252101f },
   // /* Phase: -0.688 */    { -0.034427967f, 0.039576076f, -0.046534505f, 0.056461867f, -0.071773559f, 0.098480001f, -0.156838521f, 0.381747842f, 0.846928000f, -0.201649517f, 0.114449732f, -0.079898864f, 0.061371595f, -0.049819294f, 0.041927129f },
   // /* Phase: -0.719 */    { -0.031877812f, 0.036622416f, -0.043026339f, 0.052144501f, -0.066166550f, 0.090503678f, -0.143160358f, 0.339208484f, 0.874868870f, -0.192044392f, 0.107860543f, -0.074988760f, 0.057473138f, -0.046590649f, 0.039173234f },
   // /* Phase: -0.750 */    { -0.029042462f, 0.033345047f, -0.039144188f, 0.047385070f, -0.060021088f, 0.081846938f, -0.128616616f, 0.297113955f, 0.900316298f, -0.180063263f, 0.100035146f, -0.069255099f, 0.052959785f, -0.042872205f, 0.036012653f },
   // /* Phase: -0.781 */    { -0.025951313f, 0.029778235f, -0.034929063f, 0.042234492f, -0.053403940f, 0.072605357f, -0.113366261f, 0.255677074f, 0.923125267f, -0.165689155f, 0.091012351f, -0.062736668f, 0.047865756f, -0.038693875f, 0.032471742f },
   // /* Phase: -0.812 */    { -0.022635968f, 0.025958678f, -0.030424688f, 0.036746699f, -0.046385180f, 0.062877685f, -0.097568825f, 0.215102941f, 0.943165302f, -0.148920834f, 0.080842741f, -0.055480313f, 0.042231284f, -0.034090314f, 0.028580768f },
   // /* Phase: -0.844 */    { -0.019129911f, 0.021925149f, -0.025677046f, 0.030978115f, -0.039037462f, 0.052764919f, -0.081383184f, 0.175587907f, 0.960321546f, -0.129773185f, 0.069588520f, -0.047540672f, 0.036102314f, -0.029100653f, 0.024373643f },
   // /* Phase: -0.875 */    { -0.015468180f, 0.017718097f, -0.020733943f, 0.024987061f, -0.031435333f, 0.042369362f, -0.064966358f, 0.137318119f, 0.974495351f, -0.108277261f, 0.057323255f, -0.038979813f, 0.029530162f, -0.023768179f, 0.019887660f },
   // /* Phase: -0.906 */    { -0.011687018f, 0.013379255f, -0.015644526f, 0.018833220f, -0.023654524f, 0.031793714f, -0.048472386f, 0.100468509f, 0.985605121f, -0.084480442f, 0.044131573f, -0.029866822f, 0.022571111f, -0.018139971f, 0.015163156f },
   // /* Phase: -0.938 */    { -0.007823518f, 0.008951233f, -0.010458809f, 0.012577049f, -0.015771220f, 0.021140145f, -0.032051187f, 0.065201722f, 0.993586838f, -0.058446284f, 0.030108692f, -0.020277282f, 0.015285952f, -0.012266505f, 0.010243163f },
   // /* Phase: -0.969 */    { -0.003915272f, 0.004477105f, -0.005227196f, 0.006279210f, -0.007861373f, 0.010509415f, -0.015847530f, 0.031667124f, 0.998394370f, -0.030254375f, 0.015359914f, -0.010292726f, 0.007739491f, -0.006201208f, 0.005173028f }
    ///* Phase: -0.016 */    { -0.002226277f, 0.002596360f, -0.003114014f, 0.003889488f, -0.005179266f, 0.007748825f, -0.015378438f, 0.999594152f, 0.015866643f, -0.007870854f, 0.005233500f, -0.003919994f, 0.003133537f, -0.002609918f, 0.002236238f },
    /* Phase: -0.016 */    { -0.002226277f, 0.002596360f, -0.003114014f, 0.003889488f, -0.005179266f, 0.007748825f, -0.015378438f, 0.999594152f, 0.015866643f, -0.007870854f, 0.005233500f, -0.003919994f, 0.003133537f, -0.002609918f, 0.002236238f },
    /* Phase: -0.047 */    { -0.006627868f, 0.007723950f, -0.009254392f, 0.011541191f, -0.015329070f, 0.022818081f, -0.044614457f, 0.996351123f, 0.049002767f, -0.023913350f, 0.015815707f, -0.011814896f, 0.009429554f, -0.007845587f, 0.006717233f },
    /* Phase: -0.078 */    { -0.010927046f, 0.012724811f, -0.015230620f, 0.018965332f, -0.025126658f, 0.037217680f, -0.071738429f, 0.989884257f, 0.083897486f, -0.040243510f, 0.026470330f, -0.019720923f, 0.015714131f, -0.013060559f, 0.011173706f },
    /* Phase: -0.109 */    { -0.015083657f, 0.017552592f, -0.020987963f, 0.026095299f, -0.034487758f, 0.050837509f, -0.096662872f, 0.980231822f, 0.120404623f, -0.056719534f, 0.037097640f, -0.027562505f, 0.021926722f, -0.018204413f, 0.015562503f },
    /* Phase: -0.141 */    { -0.019059258f, 0.022163056f, -0.026474411f, 0.032868229f, -0.043333735f, 0.063577235f, -0.119316176f, 0.967450798f, 0.158365101f, -0.073193960f, 0.047596071f, -0.035263486f, 0.028006691f, -0.023226881f, 0.019840730f },
    /* Phase: -0.172 */    { -0.022817463f, 0.026514469f, -0.031641133f, 0.039225526f, -0.051592194f, 0.075346872f, -0.139642864f, 0.951616645f, 0.197607830f, -0.089514658f, 0.057863068f, -0.042747818f, 0.033893902f, -0.028078325f, 0.023966167f },
    /* Phase: -0.203 */    { -0.026324267f, 0.030567976f, -0.036442902f, 0.045113333f, -0.059197497f, 0.086067282f, -0.157603726f, 0.932822585f, 0.237950712f, -0.105525970f, 0.067796014f, -0.049940273f, 0.039529271f, -0.032710206f, 0.027897671f },
    /* Phase: -0.234 */    { -0.029548351f, 0.034287937f, -0.040838469f, 0.050482977f, -0.066091239f, 0.095670536f, -0.173175782f, 0.911179066f, 0.279201776f, -0.121069796f, 0.077293143f, -0.056767166f, 0.044855367f, -0.037075575f, 0.031595580f },
    /* Phase: -0.266 */    { -0.032461360f, 0.037642226f, -0.044790898f, 0.055291329f, -0.072222643f, 0.104100220f, -0.186352253f, 0.886812925f, 0.321160257f, -0.135986775f, 0.086254470f, -0.063157037f, 0.049816940f, -0.041129515f, 0.035022117f },
    /* Phase: -0.297 */    { -0.035038136f, 0.040602505f, -0.048267875f, 0.059501126f, -0.077548862f, 0.111311629f, -0.197142288f, 0.859866500f, 0.363617986f, -0.150117517f, 0.094582714f, -0.069041394f, 0.054361492f, -0.044829614f, 0.038141746f },
    /* Phase: -0.328 */    { -0.037256937f, 0.043144453f, -0.051241945f, 0.063081242f, -0.082035229f, 0.117271841f, -0.205570638f, 0.830496550f, 0.406360567f, -0.163303778f, 0.102184236f, -0.074355334f, 0.058439814f, -0.048136376f, 0.040921554f },
    /* Phase: -0.359 */    { -0.039099615f, 0.045247957f, -0.053690724f, 0.066006877f, -0.085655436f, 0.121959724f, -0.211677223f, 0.798873305f, 0.449168742f, -0.175389707f, 0.108969934f, -0.079038277f, 0.062006459f, -0.051013626f, 0.043331575f },
    /* Phase: -0.391 */    { -0.040551752f, 0.046897259f, -0.055597037f, 0.068259709f, -0.088391602f, 0.125365868f, -0.215516612f, 0.765179217f, 0.491819948f, -0.186223090f, 0.114856154f, -0.083034538f, 0.065020263f, -0.053428907f, 0.045345102f },
    /* Phase: -0.422 */    { -0.041602768f, 0.048081055f, -0.056949034f, 0.069827966f, -0.090234309f, 0.127492353f, -0.217157304f, 0.729607522f, 0.534089565f, -0.195656583f, 0.119765542f, -0.086293951f, 0.067444757f, -0.055353820f, 0.046938989f },
    /* Phase: -0.453 */    { -0.042245992f, 0.048792586f, -0.057740226f, 0.070706449f, -0.091182530f, 0.128352478f, -0.216681063f, 0.692361057f, 0.575752497f, -0.203548878f, 0.123627841f, -0.088772416f, 0.069248587f, -0.056764334f, 0.048093885f },
    /* Phase: -0.484 */    { -0.042478692f, 0.049029622f, -0.057969499f, 0.070896491f, -0.091243468f, 0.127970397f, -0.214182049f, 0.653650880f, 0.616584659f, -0.209765911f, 0.126380712f, -0.090432420f, 0.070405863f, -0.057641059f, 0.048794471f },
    /* Phase: -0.516 */    { -0.042302065f, 0.048794471f, -0.057641059f, 0.070405863f, -0.090432420f, 0.126380712f, -0.209765911f, 0.613694608f, 0.656364322f, -0.214182049f, 0.127970397f, -0.091243468f, 0.070896491f, -0.057969499f, 0.049029622f },
    /* Phase: -0.547 */    { -0.041721199f, 0.048093885f, -0.056764334f, 0.069248587f, -0.088772416f, 0.123627841f, -0.203548878f, 0.572715044f, 0.694873750f, -0.216681063f, 0.128352478f, -0.091182530f, 0.070706449f, -0.057740226f, 0.048792586f },
    /* Phase: -0.578 */    { -0.040744979f, 0.046938989f, -0.055353820f, 0.067444757f, -0.086293951f, 0.119765542f, -0.195656583f, 0.530938804f, 0.731900513f, -0.217157304f, 0.127492353f, -0.090234309f, 0.069827966f, -0.056949034f, 0.048081055f },
    /* Phase: -0.609 */    { -0.039385993f, 0.045345102f, -0.053428907f, 0.065020263f, -0.083034538f, 0.114856154f, -0.186223090f, 0.488594294f, 0.767239153f, -0.215516612f, 0.125365868f, -0.088391602f, 0.068259709f, -0.055597037f, 0.046897259f },
    /* Phase: -0.641 */    { -0.037660364f, 0.043331575f, -0.051013626f, 0.062006459f, -0.079038277f, 0.108969934f, -0.175389707f, 0.445910722f, 0.800692141f, -0.211677223f, 0.121959724f, -0.085655436f, 0.066006877f, -0.053690724f, 0.045247957f },
    /* Phase: -0.672 */    { -0.035587583f, 0.040921554f, -0.048136376f, 0.058439814f, -0.074355334f, 0.102184236f, -0.163303778f, 0.403116137f, 0.832071602f, -0.205570638f, 0.117271841f, -0.082035229f, 0.063081242f, -0.051241945f, 0.043144453f },
    /* Phase: -0.703 */    { -0.033190284f, 0.038141746f, -0.044829614f, 0.054361492f, -0.069041394f, 0.094582714f, -0.150117517f, 0.360436112f, 0.861200511f, -0.197142288f, 0.111311629f, -0.077548862f, 0.059501126f, -0.048267875f, 0.040602505f },
    /* Phase: -0.734 */    { -0.030494004f, 0.035022117f, -0.041129515f, 0.049816940f, -0.063157037f, 0.086254470f, -0.135986775f, 0.318092167f, 0.887913644f, -0.186352253f, 0.104100220f, -0.072222643f, 0.055291329f, -0.044790898f, 0.037642226f },
    /* Phase: -0.766 */    { -0.027526936f, 0.031595580f, -0.037075575f, 0.044855367f, -0.056767166f, 0.077293143f, -0.121069796f, 0.276300311f, 0.912059128f, -0.173175782f, 0.095670536f, -0.066091239f, 0.050482977f, -0.040838469f, 0.034287937f },
    /* Phase: -0.797 */    { -0.024319611f, 0.027897671f, -0.032710206f, 0.039529271f, -0.049940273f, 0.067796014f, -0.105525970f, 0.235269666f, 0.933498979f, -0.157603726f, 0.086067282f, -0.059197497f, 0.045113333f, -0.036442902f, 0.030567976f },
    /* Phase: -0.828 */    { -0.020904621f, 0.023966167f, -0.028078325f, 0.033893902f, -0.042747818f, 0.057863068f, -0.089514658f, 0.195201159f, 0.952110469f, -0.139642864f, 0.075346872f, -0.051592194f, 0.039225526f, -0.031641133f, 0.026514469f },
    /* Phase: -0.859 */    { -0.017316263f, 0.019840730f, -0.023226881f, 0.028006691f, -0.035263486f, 0.047596071f, -0.073193960f, 0.156286135f, 0.967786789f, -0.119316176f, 0.063577235f, -0.043333735f, 0.032868229f, -0.026474411f, 0.022163056f },
    /* Phase: -0.891 */    { -0.013590225f, 0.015562503f, -0.018204413f, 0.021926722f, -0.027562505f, 0.037097640f, -0.056719534f, 0.118705325f, 0.980437696f, -0.096662872f, 0.050837509f, -0.034487758f, 0.026095299f, -0.020987963f, 0.017552592f },
    /* Phase: -0.922 */    { -0.009763218f, 0.011173706f, -0.013060559f, 0.015714131f, -0.019720923f, 0.026470330f, -0.040243510f, 0.082627609f, 0.989990294f, -0.071738429f, 0.037217680f, -0.025126658f, 0.018965332f, -0.015230620f, 0.012724811f },
    /* Phase: -0.953 */    { -0.005872630f, 0.006717233f, -0.007845587f, 0.009429554f, -0.011814896f, 0.015815707f, -0.023913350f, 0.048209105f, 0.996389568f, -0.044614457f, 0.022818081f, -0.015329070f, 0.011541191f, -0.009254392f, 0.007723950f },
    /* Phase: -0.984 */    { -0.001956161f, 0.002236238f, -0.002609918f, 0.003133537f, -0.003919994f, 0.005233500f, -0.007870854f, 0.015592244f, 0.999598444f, -0.015378438f, 0.007748825f, -0.005179266f, 0.003889488f, -0.003114014f, 0.002596360f }
};

const float Osc::VOLUME_TABLE[16] = {
    -8 * VOLUME_STEP,  // sample 0 is the minimum
    -7 * VOLUME_STEP,
    -6 * VOLUME_STEP,
    -5 * VOLUME_STEP,
    -4 * VOLUME_STEP,
    -3 * VOLUME_STEP,
    -2 * VOLUME_STEP,
    -1 * VOLUME_STEP,
     1 * VOLUME_STEP,
     2 * VOLUME_STEP,
     3 * VOLUME_STEP,
     4 * VOLUME_STEP,
     5 * VOLUME_STEP,
     6 * VOLUME_STEP,
     7 * VOLUME_STEP,
     8 * VOLUME_STEP   // sample F is the maximum
};


// Public methods ------------------------------------------------------------

uint16_t Osc::frequency() {
    return mFrequency;
}

void Osc::generate(float buf[], size_t nsamples) {
    // first, clear the output buffer
    std::fill_n(buf, nsamples, 0.0f);

    // generate samples if the waveform is not flat and we aren't muted
    if (!mMuted && mDeltaBuf.size() > 0) {

        auto deltaEnd = mDeltaBuf.end();

        if (mRecalc) {
            // frequency and/or waveform changed, recalculate deltas
            mSamplesPerDelta = (2048 - mFrequency) * mMultiplier * mFactor;
            mSamplesPerPeriod = mSamplesPerDelta * mWaveformSize;

            resetPeriod();

            mRecalc = false;
        } else {
            // we are continuing the existing waveform,
            // copy the leftovers to the start
            std::copy_n(mLeftovers, SINC_STEPS - 1, buf);
        }
        // clear the leftover buffer
        std::fill_n(mLeftovers, SINC_STEPS - 1, 0.0f);

        // add the transitions (sinc sets)

        // add steps for each delta until this limit is reached
        const size_t limit = nsamples + SINC_CENTER;
        // when a center of transition exceeds this limit, the transition is outside of the output buffer
        // (which will be the first transition to generate on the next call)
        for (auto iter = mDeltaBuf.begin(); iter != deltaEnd; ++iter) {
            // cache these values
            float position = iter->position; // this is the location in the buffer, in samples, of the current transition 
            float change = iter->change;

            while (position < limit) {

                float positionWhole;
                float positionFract = modff(position, &positionWhole);
                // index of the center of the step
                size_t centerIndex = static_cast<size_t>(positionWhole);
                // the sinc set chosen is determined by the fractional part of position
                float phase = positionFract * SINC_PHASES;

                const float *sincset = SINC_TABLE[static_cast<size_t>(phase)];

                // ending index of the band limited step
                size_t endIndex = centerIndex + (SINC_STEPS - SINC_CENTER);

                // determine the range of the set to use
                size_t sincStart;
                size_t sincEnd;
                float *dest = buf;

                if (centerIndex < SINC_CENTER) {
                    // we are at the start of the buffer
                    sincStart = SINC_CENTER - centerIndex;
                } else {
                    // we are somewhere in between
                    sincStart = 0;
                    // point dest to the start of the step
                    dest += centerIndex - SINC_CENTER;
                }

                if (endIndex > nsamples) {
                    // we are at the end of the buffer
                    sincEnd = SINC_STEPS - (endIndex - nsamples);
                } else {
                    sincEnd = SINC_STEPS;
                }

                // copy to the buffer
                float error = change;  // precision error
                for (size_t i = sincStart; i != sincEnd; ++i) {
                    float sample = change * sincset[i];
                    error -= sample;
                    *dest++ += sample;
                }

                // copy to leftovers (if needed)
                dest = mLeftovers;
                for (size_t i = sincEnd; i != SINC_STEPS; ++i) {
                    float sample = change * sincset[i];
                    error -= sample;
                    *dest++ += sample;
                }

                // add the error so that the sum of the step is equal to change
                // (this error comes from taking the floor of a sample in the step)
                if (centerIndex >= nsamples) {
                    mLeftovers[centerIndex - nsamples] += error;
                } else {
                    buf[centerIndex] += error;
                }


                // next period
                position += mSamplesPerPeriod;
            }

            iter->position = position - nsamples;

        }

        // do the running sum
        for (size_t i = 0; i != nsamples; ++i) {
            *buf += mPrevious;
            mPrevious = *buf++;
            //assert(mPrevious <= 1.0f && mPrevious >= -1.0f);
        }

    }

}

bool Osc::muted() {
    return mMuted;
}

float Osc::outputFrequency() {
    // period of the oscilator is (2048 - mFrequency) * multiplier * waveformSize
    // example ranges (multiplier, waveformSize)
    // PulseOsc: (4, 8):    64 Hz - 131,072 Hz
    // WaveOsc: (2, 32):    32 Hz - 65,536 Hz
    return Gbs::CLOCK_SPEED / ((2048 - mFrequency) * mMultiplier * mWaveformSize);
}

void Osc::reset() {
    // just reset the period if the frequency/waveform is unchanged
    if (!mRecalc) {
        resetPeriod();
    }
}

void Osc::setFrequency(uint16_t frequency) {
    if (frequency > mNyquist) {
        // keep higher frequencies the same as the nyquist (to prevent aliasing)
        mFrequency = mNyquist;
    } else {
        mFrequency = frequency;
    }
    // recalculate on next call to generate()
    mRecalc = true;
}


void Osc::setMute(bool muted) {
    mMuted = muted;
}


// protected methods ---------------------------------------------------------


Osc::Osc(float samplingRate, size_t multiplier, size_t waveformSize) :
    mMultiplier(multiplier),
    mWaveformSize(waveformSize),
    mFactor(samplingRate / Gbs::CLOCK_SPEED),
    mFrequency(Gbs::DEFAULT_FREQUENCY),
    mRecalc(true),
    mSamplesPerDelta(0.0f),
    mSamplesPerPeriod(0.0f),
    mPrevious(0),
    mLeftovers{ 0 },
    mDeltaBuf(),
    mMuted(false)
{
    // assert that waveform size is a power of 2
    assert((mWaveformSize & (mWaveformSize - 1)) == 0);

    float nyquist = samplingRate * 0.5f;
    mNyquist = static_cast<uint16_t>(2048 - Gbs::CLOCK_SPEED / (nyquist * multiplier * waveformSize));

}


void Osc::deltaSet(const uint8_t waveform[]) {

    // clear existing waveform
    mDeltaBuf.clear();

    // convert waveform to a delta buffer

    size_t bufsize = mWaveformSize / 2;
    // bitmask used to wrap -1 to bufsize-1 or bufsize to 0
    size_t mask = bufsize - 1;
    uint8_t lo; // keep lo out here cause we need the last one for initSample
    size_t waveIndex = 0;
    size_t deltaIndex = 0;

    // the starting volume is the first samples
    int16_t previous = SAMPLE_TABLE[waveform[0] >> 4];
    mPrevious = previous;

    for (size_t i = 0; i != mWaveformSize; ++i) {

        uint8_t hi = waveform[waveIndex];
        lo = hi & 0xF;
        hi >>= 4;


        int8_t delta;
        if ((i & 1) == 1) {
            // for odd numbered indices, the delta is calculated by
            // subtracting the high nibble of the next byte from the low nibble of the current byte
            delta = (waveform[(waveIndex + 1) & mask] >> 4) - lo;
            ++waveIndex;
        } else {
            // even numbered indices, the delta is the lower nibble
            // minus the high nibble of the current byte
            delta = lo - hi;
        }

        if (delta) {
            Delta d;
            d.change = SAMPLE_TABLE[abs(delta)];
            if (delta < 0) {
                d.change = -d.change;
            }
            d.location = static_cast<uint8_t>(i);
            d.before = previous;
            previous += d.change;
            mDeltaBuf.push_back(d);
            ++deltaIndex;
        }
    }

    mRecalc = true;


}

void Osc::resetPeriod() {
    // calculate initial positions
    for (auto iter = mDeltaBuf.begin(); iter != mDeltaBuf.end(); ++iter) {
        iter->position = iter->location * mSamplesPerDelta;
    }

    // initialize previous with the starting sample of the waveform
    mPrevious = mDeltaBuf[0].before;
}

}

#include "trackerboy/synth/Osc.hpp"
#include "trackerboy/gbs.hpp"

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstddef>


namespace {

template <typename T>
void circlecopy(T src[], size_t srcSize, int destPos, T dest[], size_t dstSize) {
    for (size_t i = 0; i != srcSize; ++i) {
        int index;
        if (destPos < 0) {
            auto dstSizeInt = static_cast<int>(dstSize);
            index = ((destPos % dstSizeInt) + dstSizeInt) % dstSizeInt;
        } else if (destPos >= dstSize) {
            index = destPos % dstSize;
        } else {
            index = destPos;
        }
        dest[index] += src[i];
        ++destPos;
    }
}


}


namespace trackerboy {

const float Osc::STEP_TABLE[Osc::STEP_PHASES][Osc::STEP_WIDTH] = {
    // this table was generated by genstep.py
    // genstep.py 48000 64 32 16
    /* Phase:  0.000 */    {  0.000687230f, -0.001788836f,  0.002571344f, -0.004002845f,  0.007034825f, -0.014529911f,  0.235105664f,  0.550034881f,  0.235295504f, -0.014529911f,  0.007034825f, -0.004002845f,  0.002571344f, -0.001788836f,  0.001315700f, -0.001008166f },
    /* Phase: -0.031 */    {  0.000690953f, -0.001799706f,  0.002593471f, -0.004054342f,  0.007189595f, -0.015447486f,  0.221296206f,  0.549617767f,  0.249267891f, -0.013304434f,  0.006793251f, -0.003907583f,  0.002522443f, -0.001759801f,  0.001296770f, -0.000994989f },
    /* Phase: -0.062 */    {  0.000687247f, -0.001792693f,  0.002589311f, -0.004063041f,  0.007260215f, -0.016077779f,  0.207687557f,  0.548371136f,  0.263367116f, -0.011750909f,  0.006462957f, -0.003767987f,  0.002446538f, -0.001712488f,  0.001264614f, -0.000971783f },
    /* Phase: -0.094 */    {  0.000676291f, -0.001768247f,  0.002559584f, -0.004030289f,  0.007250012f, -0.016441761f,  0.194313258f,  0.546299458f,  0.277555197f, -0.009849798f,  0.006042823f, -0.003583910f,  0.002343653f, -0.001646963f,  0.001219301f, -0.000938614f },
    /* Phase: -0.125 */    {  0.000658330f, -0.001726975f,  0.002505239f, -0.003957781f,  0.007162931f, -0.016560614f,  0.181205109f,  0.543410063f,  0.291793019f, -0.007582299f,  0.005532583f, -0.003355641f,  0.002214082f, -0.001563469f,  0.001161030f, -0.000895644f },
    /* Phase: -0.156 */    {  0.000633671f, -0.001669629f,  0.002427438f, -0.003847540f,  0.007003459f, -0.016455622f,  0.168393046f,  0.539713323f,  0.306040436f, -0.004930481f,  0.004932873f, -0.003083922f,  0.002058389f, -0.001462433f,  0.001090132f, -0.000843135f },
    /* Phase: -0.188 */    {  0.000602678f, -0.001597104f,  0.002327534f, -0.003701883f,  0.006776563f, -0.016148042f,  0.155905098f,  0.535222352f,  0.320256352f, -0.001877408f,  0.004245280f, -0.002769954f,  0.001877412f, -0.001344463f,  0.001007064f, -0.000781445f },
    /* Phase: -0.219 */    {  0.000565771f, -0.001510418f,  0.002207060f, -0.003523388f,  0.006487624f, -0.015658984f,  0.143767238f,  0.529953003f,  0.334399074f,  0.001592729f,  0.003472385f, -0.002415403f,  0.001672260f, -0.001210346f,  0.000912415f, -0.000711029f },
    /* Phase: -0.250 */    {  0.000523418f, -0.001410705f,  0.002067706f, -0.003314866f,  0.006142366f, -0.015009303f,  0.132003352f,  0.523923993f,  0.348426402f,  0.005494489f,  0.002617797f, -0.002022405f,  0.001444314f, -0.001061045f,  0.000806895f, -0.000632432f },
    /* Phase: -0.281 */    {  0.000476130f, -0.001299199f,  0.001911300f, -0.003079323f,  0.005746786f, -0.014219489f,  0.120635159f,  0.517156661f,  0.362295717f,  0.009841058f,  0.001686188f, -0.001593562f,  0.001195220f, -0.000897697f,  0.000691335f, -0.000546291f },
    /* Phase: -0.312 */    {  0.000424455f, -0.001177223f,  0.001739787f, -0.002819927f,  0.005307097f, -0.013309569f,  0.109682165f,  0.509674728f,  0.375964344f,  0.014644136f,  0.000683316f, -0.001131937f,  0.000926879f, -0.000721599f,  0.000566681f, -0.000453325f },
    /* Phase: -0.344 */    {  0.000368975f, -0.001046172f,  0.001555211f, -0.002539977f,  0.004829650f, -0.012299008f,  0.099161617f,  0.501504421f,  0.389389575f,  0.019913817f, -0.000383957f, -0.000641038f,  0.000641436f, -0.000534207f,  0.000433985f, -0.000354332f },
    /* Phase: -0.375 */    {  0.000310296f, -0.000907499f,  0.001359686f, -0.002242860f,  0.004320879f, -0.011206622f,  0.089088507f,  0.492674291f,  0.402528942f,  0.025658498f, -0.001507654f, -0.000124808f,  0.000341273f, -0.000337120f,  0.000294399f, -0.000250182f },
    /* Phase: -0.406 */    {  0.000249044f, -0.000762702f,  0.001155383f, -0.001932025f,  0.003787235f, -0.010050495f,  0.079475522f,  0.483214915f,  0.415340394f,  0.031884756f, -0.002678678f,  0.000412395f,  0.000028983f, -0.000132070f,  0.000149166f, -0.000141811f },
    /* Phase: -0.438 */    {  0.000185858f, -0.000613306f,  0.000944502f, -0.001610945f,  0.003235131f, -0.008847907f,  0.070333056f,  0.473158956f,  0.427782506f,  0.038597289f, -0.003886812f,  0.000965828f, -0.000292641f,  0.000079091f, -0.000000393f, -0.000030211f },
    /* Phase: -0.469 */    {  0.000121383f, -0.000460850f,  0.000729251f, -0.001283082f,  0.002670879f, -0.007615265f,  0.061669238f,  0.462540925f,  0.439814597f,  0.045798801f, -0.005120736f,  0.001530387f, -0.000620630f,  0.000294405f, -0.000152887f,  0.000083578f },
    /* Phase: -0.500 */    {  0.000056266f, -0.000306870f,  0.000511831f, -0.000951860f,  0.002100643f, -0.006368043f,  0.053489938f,  0.451397002f,  0.451397002f,  0.053489938f, -0.006368043f,  0.002100643f, -0.000951860f,  0.000511831f, -0.000306870f,  0.000198474f },
    /* Phase: -0.531 */    { -0.000008851f, -0.000152887f,  0.000294405f, -0.000620630f,  0.001530387f, -0.005120736f,  0.045798801f,  0.439764827f,  0.462491155f,  0.061669238f, -0.007615265f,  0.002670879f, -0.001283082f,  0.000729251f, -0.000460850f,  0.000313368f },
    /* Phase: -0.562 */    { -0.000073340f, -0.000000393f,  0.000079091f, -0.000292641f,  0.000965828f, -0.003886812f,  0.038597289f,  0.427683443f,  0.473059893f,  0.070333056f, -0.008847907f,  0.003235131f, -0.001610945f,  0.000944502f, -0.000613306f,  0.000427133f },
    /* Phase: -0.594 */    { -0.000136589f,  0.000149166f, -0.000132070f,  0.000028983f,  0.000412395f, -0.002678678f,  0.031884756f,  0.415192991f,  0.483067513f,  0.079475522f, -0.010050495f,  0.003787235f, -0.001932025f,  0.001155383f, -0.000762702f,  0.000538629f },
    /* Phase: -0.625 */    { -0.000198008f,  0.000294399f, -0.000337120f,  0.000341273f, -0.000124808f, -0.001507654f,  0.025658498f,  0.402334630f,  0.492479980f,  0.089088507f, -0.011206622f,  0.004320879f, -0.002242860f,  0.001359686f, -0.000907499f,  0.000646722f },
    /* Phase: -0.656 */    { -0.000257037f,  0.000433985f, -0.000534207f,  0.000641436f, -0.000641038f, -0.000383957f,  0.019913817f,  0.389150262f,  0.501265109f,  0.099161617f, -0.012299008f,  0.004829650f, -0.002539977f,  0.001555211f, -0.001046172f,  0.000750291f },
    /* Phase: -0.688 */    { -0.000313146f,  0.000566681f, -0.000721599f,  0.000926879f, -0.001131937f,  0.000683316f,  0.014644136f,  0.375682354f,  0.509392738f,  0.109682165f, -0.013309569f,  0.005307097f, -0.002819927f,  0.001739787f, -0.001177223f,  0.000848237f },
    /* Phase: -0.719 */    { -0.000365846f,  0.000691335f, -0.000897697f,  0.001195220f, -0.001593562f,  0.001686188f,  0.009841058f,  0.361973822f,  0.516834736f,  0.120635159f, -0.014219489f,  0.005746786f, -0.003079323f,  0.001911300f, -0.001299199f,  0.000939498f },
    /* Phase: -0.750 */    { -0.000414685f,  0.000806895f, -0.001061045f,  0.001444314f, -0.002022405f,  0.002617797f,  0.005494489f,  0.348067701f,  0.523565352f,  0.132003352f, -0.015009303f,  0.006142366f, -0.003314866f,  0.002067706f, -0.001410705f,  0.001023059f },
    /* Phase: -0.781 */    { -0.000459261f,  0.000912415f, -0.001210346f,  0.001672260f, -0.002415403f,  0.003472385f,  0.001592729f,  0.334007114f,  0.529561043f,  0.143767238f, -0.015658984f,  0.006487624f, -0.003523388f,  0.002207060f, -0.001510418f,  0.001097959f },
    /* Phase: -0.812 */    { -0.000499215f,  0.001007064f, -0.001344463f,  0.001877412f, -0.002769954f,  0.004245280f, -0.001877408f,  0.319834918f,  0.534800887f,  0.155905098f, -0.016148042f,  0.006776563f, -0.003701883f,  0.002327534f, -0.001597104f,  0.001163309f },
    /* Phase: -0.844 */    { -0.000534241f,  0.001090132f, -0.001462433f,  0.002058389f, -0.003083922f,  0.004932873f, -0.004930481f,  0.305593669f,  0.539266586f,  0.168393046f, -0.016455622f,  0.007003459f, -0.003847540f,  0.002427438f, -0.001669629f,  0.001218291f },
    /* Phase: -0.875 */    { -0.000564085f,  0.001161030f, -0.001563469f,  0.002214082f, -0.003355641f,  0.005532583f, -0.007582299f,  0.291325331f,  0.542942405f,  0.181205109f, -0.016560614f,  0.007162931f, -0.003957781f,  0.002505239f, -0.001726975f,  0.001262179f },
    /* Phase: -0.906 */    { -0.000588547f,  0.001219301f, -0.001646963f,  0.002343653f, -0.003583910f,  0.006042823f, -0.009849798f,  0.277071148f,  0.545815408f,  0.194313258f, -0.016441761f,  0.007250012f, -0.004030289f,  0.002559584f, -0.001768247f,  0.001294339f },
    /* Phase: -0.938 */    { -0.000607482f,  0.001264614f, -0.001712488f,  0.002446538f, -0.003767987f,  0.006462957f, -0.011750909f,  0.262871474f,  0.547875464f,  0.207687557f, -0.016077779f,  0.007260215f, -0.004063041f,  0.002589311f, -0.001792693f,  0.001314241f },
    /* Phase: -0.969 */    { -0.000620802f,  0.001296770f, -0.001759801f,  0.002522443f, -0.003907583f,  0.006793251f, -0.013304434f,  0.248765543f,  0.549115419f,  0.221296206f, -0.015447486f,  0.007189595f, -0.004054342f,  0.002593471f, -0.001799706f,  0.001321462f }
}; 
#if 0
{
    // this table was generated by genstep.py
    // genstep.py 48000 64 32 16
    /* Phase:  0.000 */    { -0.003784475f, -0.003535828f,  0.004340462f, -0.005829123f,  0.009078607f, -0.018622857f,  0.078168809f,  0.878319860f,  0.076119840f, -0.018622857f,  0.009078607f, -0.005829123f,  0.004340462f, -0.003535828f,  0.003052017f, -0.002738550f },
    /* Phase: -0.031 */    { -0.005327771f, -0.000169666f,  0.000291439f, -0.000744221f,  0.002225769f, -0.008001324f,  0.052062213f,  0.877660334f,  0.104194060f, -0.029417379f,  0.015990680f, -0.010938583f,  0.008398815f, -0.006903260f,  0.005929855f, -0.005250984f },
    /* Phase: -0.062 */    { -0.006857183f,  0.003163166f, -0.003709834f,  0.004268206f, -0.004504234f,  0.002353548f,  0.027424902f,  0.874504030f,  0.133539170f, -0.040286299f,  0.022896413f, -0.016023669f,  0.012427498f, -0.010239549f,  0.008776450f, -0.007732605f },
    /* Phase: -0.094 */    { -0.008358261f,  0.006431256f, -0.007625873f,  0.009161680f, -0.011050299f,  0.012353589f,  0.004336254f,  0.868865550f,  0.164039060f, -0.051126759f,  0.029728813f, -0.021034885f,  0.016387289f, -0.013512234f,  0.011564126f, -0.010159300f },
    /* Phase: -0.125 */    { -0.009816961f,  0.009604135f, -0.011420466f,  0.013891567f, -0.017354323f,  0.021916678f, -0.017135506f,  0.860773146f,  0.195568398f, -0.061832327f,  0.036420058f, -0.025922617f,  0.020239117f, -0.016689116f,  0.014265519f, -0.012507295f },
    /* Phase: -0.156 */    { -0.011219775f,  0.012652548f, -0.015058996f,  0.018415462f, -0.023361657f,  0.030967221f, -0.036933571f,  0.850268304f,  0.227993354f, -0.072293706f,  0.042902090f, -0.030637598f,  0.023944430f, -0.019738562f,  0.016853841f, -0.014753380f },
    /* Phase: -0.188 */    { -0.012553850f,  0.015548721f, -0.018508749f,  0.022693552f, -0.029021539f,  0.039436568f, -0.055012733f,  0.837405682f,  0.261172295f, -0.082399532f,  0.049107224f, -0.035131380f,  0.027465567f, -0.022629824f,  0.019303137f, -0.016875131f },
    /* Phase: -0.219 */    { -0.013807107f,  0.018266609f, -0.021739192f,  0.026688935f, -0.034287456f,  0.047263388f, -0.071339481f,  0.822252572f,  0.294956684f, -0.092037149f,  0.054968778f, -0.039356798f,  0.030766128f, -0.025333321f,  0.021588551f, -0.018851142f },
    /* Phase: -0.250 */    { -0.014968345f,  0.020782117f, -0.024722239f,  0.030367931f, -0.039117496f,  0.054393932f, -0.085892022f,  0.804888606f,  0.329191953f, -0.101093441f,  0.060421702f, -0.043268427f,  0.033811335f, -0.027820952f,  0.023686554f, -0.020661226f },
    /* Phase: -0.281 */    { -0.016027341f,  0.023073314f, -0.027432477f,  0.033700336f, -0.043474626f,  0.060782306f, -0.098660186f,  0.785405278f,  0.363718361f, -0.109455675f,  0.065403208f, -0.046823047f,  0.036568381f, -0.030066375f,  0.025575206f, -0.022286622f },
    /* Phase: -0.312 */    { -0.016974937f,  0.025120620f, -0.029847380f,  0.036659647f, -0.047326934f,  0.066390589f, -0.109645329f,  0.763905048f,  0.398372054f, -0.117012337f,  0.069853365f, -0.049980074f,  0.039006766f, -0.032045264f,  0.027234353f, -0.023710191f },
    /* Phase: -0.344 */    { -0.017803114f,  0.026906956f, -0.031947475f,  0.039223265f, -0.050647821f,  0.071188956f, -0.118860044f,  0.740501225f,  0.432986021f, -0.123654038f,  0.073715761f, -0.052701995f,  0.041098613f, -0.033735584f,  0.028645860f, -0.024916582f },
    /* Phase: -0.375 */    { -0.018505065f,  0.028417893f, -0.033716507f,  0.041372646f, -0.053416137f,  0.075155690f, -0.126327932f,  0.715316713f,  0.467391223f, -0.129274324f,  0.076938018f, -0.054954760f,  0.042818982f, -0.035117805f,  0.029793786f, -0.025892405f },
    /* Phase: -0.406 */    { -0.019075235f,  0.029641751f, -0.035141528f,  0.043093402f, -0.055616271f,  0.078277171f, -0.132083133f,  0.688483417f,  0.501417518f, -0.133770570f,  0.079472445f, -0.056708165f,  0.044146121f, -0.036175124f,  0.030664563f, -0.026626363f },
    /* Phase: -0.438 */    { -0.019509381f,  0.030569695f, -0.036212999f,  0.044375382f, -0.057238191f,  0.080547750f, -0.136169970f,  0.660141647f,  0.534894705f, -0.137044802f,  0.081276514f, -0.057936206f,  0.045061741f, -0.036893670f,  0.031247150f, -0.027109390f },
    /* Phase: -0.469 */    { -0.019804578f,  0.031195775f, -0.036924843f,  0.045212720f, -0.058277428f,  0.081969582f, -0.138642401f,  0.630438685f,  0.567653954f, -0.139004499f,  0.082313396f, -0.058617391f,  0.045551222f, -0.037262633f,  0.031533163f, -0.027334746f },
    /* Phase: -0.500 */    { -0.019959260f,  0.031516965f, -0.037274439f,  0.045603793f, -0.058735020f,  0.082552440f, -0.139563426f,  0.599528372f,  0.599528372f, -0.139563426f,  0.082552440f, -0.058735020f,  0.045603793f, -0.037274439f,  0.031516965f, -0.027298102f },
    /* Phase: -0.531 */    { -0.019973196f,  0.031533163f, -0.037262633f,  0.045551222f, -0.058617391f,  0.082313396f, -0.139004499f,  0.567569673f,  0.630354464f, -0.138642401f,  0.081969582f, -0.058277428f,  0.045212720f, -0.036924843f,  0.031195775f, -0.026997609f },
    /* Phase: -0.562 */    { -0.019847505f,  0.031247150f, -0.036893670f,  0.045061741f, -0.057936206f,  0.081276514f, -0.137044802f,  0.534726083f,  0.659972966f, -0.136169970f,  0.080547750f, -0.057238191f,  0.044375382f, -0.036212999f,  0.030569695f, -0.026433926f },
    /* Phase: -0.594 */    { -0.019584613f,  0.030664563f, -0.036175124f,  0.044146121f, -0.056708165f,  0.079472445f, -0.133770570f,  0.501164138f,  0.688230097f, -0.132083133f,  0.078277171f, -0.055616271f,  0.043093402f, -0.035141528f,  0.029641751f, -0.025610242f },
    /* Phase: -0.625 */    { -0.019188233f,  0.029793786f, -0.035117805f,  0.042818982f, -0.054954760f,  0.076938018f, -0.129274324f,  0.467052728f,  0.714978218f, -0.126327932f,  0.075155690f, -0.053416137f,  0.041372646f, -0.033716507f,  0.028417893f, -0.024532266f },
    /* Phase: -0.656 */    { -0.018663315f,  0.028645860f, -0.033735584f,  0.041098613f, -0.052701995f,  0.073715761f, -0.123654038f,  0.432561934f,  0.740077138f, -0.118860044f,  0.071188956f, -0.050647821f,  0.039223265f, -0.031947475f,  0.026906956f, -0.023208190f },
    /* Phase: -0.688 */    { -0.018015981f,  0.027234353f, -0.032045264f,  0.039006766f, -0.049980074f,  0.069853365f, -0.117012337f,  0.397861779f,  0.763394833f, -0.109645329f,  0.066390589f, -0.047326934f,  0.036659647f, -0.029847380f,  0.025120620f, -0.021648636f },
    /* Phase: -0.719 */    { -0.017253468f,  0.025575206f, -0.030066375f,  0.036568381f, -0.046823047f,  0.065403208f, -0.109455675f,  0.363121390f,  0.784808278f, -0.098660186f,  0.060782306f, -0.043474626f,  0.033700336f, -0.027432477f,  0.023073314f, -0.019866575f },
    /* Phase: -0.750 */    { -0.016384043f,  0.023686554f, -0.027820952f,  0.033811335f, -0.043268427f,  0.060421702f, -0.101093441f,  0.328507781f,  0.804204464f, -0.085892022f,  0.054393932f, -0.039117496f,  0.030367931f, -0.024722239f,  0.020782117f, -0.017877219f },
    /* Phase: -0.781 */    { -0.015416916f,  0.021588551f, -0.025333321f,  0.030766128f, -0.039356798f,  0.054968778f, -0.092037149f,  0.294184983f,  0.821480870f, -0.071339481f,  0.047263388f, -0.034287456f,  0.026688935f, -0.021739192f,  0.018266609f, -0.015697902f },
    /* Phase: -0.812 */    { -0.014362147f,  0.019303137f, -0.022629824f,  0.027465567f, -0.035131380f,  0.049107224f, -0.082399532f,  0.260312825f,  0.836546242f, -0.055012733f,  0.039436568f, -0.029021539f,  0.022693552f, -0.018508749f,  0.015548721f, -0.013347929f },
    /* Phase: -0.844 */    { -0.013230545f,  0.016853841f, -0.019738562f,  0.023944430f, -0.030637598f,  0.042902090f, -0.072293706f,  0.227046251f,  0.849321187f, -0.036933571f,  0.030967221f, -0.023361657f,  0.018415462f, -0.015058996f,  0.012652548f, -0.010848409f },
    /* Phase: -0.875 */    { -0.012033555f,  0.014265519f, -0.016689116f,  0.020239117f, -0.025922617f,  0.036420058f, -0.061832327f,  0.194534078f,  0.859738827f, -0.017135506f,  0.021916678f, -0.017354323f,  0.013891567f, -0.011420466f,  0.009604135f, -0.008222071f },
    /* Phase: -0.906 */    { -0.010783146f,  0.011564126f, -0.013512234f,  0.016387289f, -0.021034885f,  0.029728813f, -0.051126759f,  0.162918374f,  0.867744863f,  0.004336254f,  0.012353589f, -0.011050299f,  0.009161680f, -0.007625873f,  0.006431256f, -0.005493056f },
    /* Phase: -0.938 */    { -0.009491698f,  0.008776450f, -0.010239549f,  0.012427498f, -0.016023669f,  0.022896413f, -0.040286299f,  0.132333472f,  0.873298347f,  0.027424902f,  0.002353548f, -0.004504234f,  0.004268206f, -0.003709834f,  0.003163166f, -0.002686710f },
    /* Phase: -0.969 */    { -0.008171870f,  0.005929855f, -0.006903260f,  0.008398815f, -0.010938583f,  0.015990680f, -0.029417379f,  0.102905288f,  0.876371562f,  0.052062213f, -0.008001324f,  0.002225769f, -0.000744221f,  0.000291439f, -0.000169666f,  0.000170660f }
};
#endif

const float Osc::VOLUME_TABLE[16] = {
    VOLUME_MIN,
    VOLUME_MIN + (VOLUME_STEP * 1),
    VOLUME_MIN + (VOLUME_STEP * 2),
    VOLUME_MIN + (VOLUME_STEP * 3),
    VOLUME_MIN + (VOLUME_STEP * 4),
    VOLUME_MIN + (VOLUME_STEP * 5),
    VOLUME_MIN + (VOLUME_STEP * 6),
    VOLUME_MIN + (VOLUME_STEP * 7),
    VOLUME_MIN + (VOLUME_STEP * 8),
    VOLUME_MIN + (VOLUME_STEP * 9),
    VOLUME_MIN + (VOLUME_STEP * 10),
    VOLUME_MIN + (VOLUME_STEP * 11),
    VOLUME_MIN + (VOLUME_STEP * 12),
    VOLUME_MIN + (VOLUME_STEP * 13),
    VOLUME_MIN + (VOLUME_STEP * 14),
     VOLUME_MAX

    #if 0
    0.0f,
    1 * VOLUME_STEP,
    2 * VOLUME_STEP,
    3 * VOLUME_STEP,
    4 * VOLUME_STEP,
    5 * VOLUME_STEP,
    6 * VOLUME_STEP,
    7 * VOLUME_STEP,
    8 * VOLUME_STEP,
    9 * VOLUME_STEP,
    10 * VOLUME_STEP,
    11 * VOLUME_STEP,
    12 * VOLUME_STEP,
    13 * VOLUME_STEP,
    14 * VOLUME_STEP,
    VOLUME_MAX
    #endif
};


// Public methods ------------------------------------------------------------

void Osc::disable() {
    mDisabled = true;
}

bool Osc::disabled() {
    return mDisabled;
}

uint16_t Osc::frequency() {
    return mFrequency;
}

void Osc::generate(float buf[], size_t nsamples) {
    
    if (mDisabled || mDeltaBuf.size() == 0 || mFrequency > mNyquist) {
        // output silence because:
        //  * oscillator is disabled OR
        //  * waveform is flat OR
        //  * frequency is too high
        std::fill_n(buf, nsamples, 0.0f);
        run(nsamples);
    } else {

        if (mRegenPeriod) {
            fillPeriod();
            mRegenPeriod = false;
        }

        size_t remaining = nsamples;

        // copy from phase to end of period

        auto pbegin = mPeriodBuf.begin();
        auto pend = mPeriodBuf.end();

        float *dest = buf;
        size_t periodsize = mPeriodBuf.size();
        size_t toCopy = std::min(remaining, periodsize - mPeriodOffset);
        std::copy_n(pbegin + mPeriodOffset, toCopy, dest);

        dest += toCopy;
        remaining -= toCopy;
        mPeriodOffset += toCopy;

        while (remaining >= periodsize) {
            std::copy(pbegin, pend, dest);
            dest += periodsize;
            remaining -= periodsize;
        }

        if (mPeriodOffset == periodsize) {
            std::copy(pbegin, pbegin + remaining, dest);
            mPeriodOffset = remaining;
        }

    }

}

float Osc::outputFrequency() {
    // period of the oscilator is (2048 - mFrequency) * multiplier * waveformSize
    // example ranges (multiplier, waveformSize)
    // PulseOsc: (4, 8):    64 Hz - 131,072 Hz
    // WaveOsc: (2, 32):    32 Hz - 65,536 Hz
    return Gbs::CLOCK_SPEED / ((2048 - mFrequency) * mMultiplier * mWaveformSize);
}

void Osc::reset() {
    mPeriodOffset = 0;
    mDisabled = false;
}

void Osc::run(size_t nsamples) {
    if (mRegenPeriod) {
        fillPeriod();
        mRegenPeriod = false;
    }

    mPeriodOffset = (mPeriodOffset + nsamples) % mPeriodBuf.size();
}

void Osc::setFrequency(uint16_t frequency) {
    if (frequency != mFrequency) {
        mFrequency = frequency;
        mRegenPeriod = true;
    }
}

// protected methods ---------------------------------------------------------


Osc::Osc(float samplingRate, size_t multiplier, size_t waveformSize) :
    mMultiplier(multiplier),
    mWaveformSize(waveformSize),
    mFactor(samplingRate / Gbs::CLOCK_SPEED),
    mFrequency(Gbs::DEFAULT_FREQUENCY),
    mDeltaBuf(),
    mRegenPeriod(true),
    mDisabled(false),
    mPeriodBufSize(PERIOD_BUFFER_SIZE_DEFAULT),
    mPeriodBuf(),
    mPeriodOffset(0)
{
    // assert that waveform size is a power of 2
    assert((mWaveformSize & (mWaveformSize - 1)) == 0);

    float nyquist = samplingRate * 0.5f;
    mNyquist = static_cast<uint16_t>(2048 - Gbs::CLOCK_SPEED / (nyquist * multiplier * waveformSize));

}


void Osc::fillPeriod() {

    // TODO: determine best fitting LSB from a fixed period buffer size

    // LSB for quantizing the frequency
    // PulseOsc: 8 * 1/128 -> 1/16, 16 max unique periods
    // WaveOsc:  32 * 1/128 -> 1/4, 4 max unique periods
    // lowering the LSB lowers the maximum size of the period buffer but
    // increases frequency error
    //
    // we quantize the timing variables so that we limit the number of max unique
    // periods. A unique period has a unique set of phases for each transition.
    // Doing so we can sample a buffer that loops seamlessly, which we can
    // sample from to fill any sized buffer.

    constexpr float LSB = 1 / 128.0f;

    // spd : samples per delta transition
    float spd = (2048 - mFrequency) * mMultiplier * mFactor;
    // quantize spd
    spd = LSB * floorf((spd / LSB) + 0.5f);
    // spp : samples per period
    float spp = spd * mWaveformSize;

    unsigned nperiods = static_cast<unsigned>(1.0f / (LSB * mWaveformSize));
    // spp is casted to double to prevent stupid arithmetic overflow warnings
    size_t bufsize = static_cast<size_t>(nperiods * static_cast<double>(spp));
    assert((nperiods * spp) - bufsize == 0);

    // adjust phase proportionally to new buffer size
    if (mPeriodBuf.size() != 0) {
        mPeriodOffset = (mPeriodOffset * bufsize) / mPeriodBuf.size();
    } else {
        mPeriodOffset = 0;
    }
    mPeriodBuf.resize(bufsize);
    std::fill(mPeriodBuf.begin(), mPeriodBuf.end(), 0.0f);

    if (mFrequency <= mNyquist && mDeltaBuf.size() > 0) {

        // wraparound buffer, used to replace the start of the period buf so that
        // the entire loops seamlessly.
        float wraparound[STEP_WIDTH - 1];
        // make sure it is zero'd
        std::fill_n(wraparound, STEP_WIDTH - 1, 0.0f);
        float *periodBufData = mPeriodBuf.data();


        for (auto &delta : mDeltaBuf) {
            float position = delta.location * spd;
            float change = delta.change;

            for (size_t p = 0; p != nperiods; ++p) {

                // determine step set
                float positionWhole;
                float positionFract = modff(position, &positionWhole);
                // the step set chosen is determined by the fractional part of position
                float phase = positionFract * STEP_PHASES;
                const float *stepset = STEP_TABLE[static_cast<size_t>(phase)];

                // calculate indexing of the step
                size_t positionIndex = static_cast<size_t>(positionWhole);
                size_t endIndex = positionIndex + STEP_WIDTH;
                size_t stepEnd; // how much of the step that gets copied, remainder goes to wraparound
                size_t center1 = positionIndex + STEP_CENTER - 1;
                size_t center2 = positionIndex + STEP_CENTER;
                if (endIndex > bufsize) {
                    // at the end of buffer
                    stepEnd = bufsize - positionIndex;
                } else {
                    // plenty of room
                    stepEnd = STEP_WIDTH;
                }

                // add the step to the period buffer at position
                float *dest = periodBufData + positionIndex;
                // step must sum to the amount it changes by, keep track of precision error
                float error = change;
                for (size_t i = 0; i != stepEnd; ++i) {
                    float sample = change * stepset[i];
                    error -= sample;
                    *dest++ += sample;
                }

                // add the step to wraparound, only when endIndex > bufsize
                dest = wraparound;
                for (size_t i = stepEnd; i != STEP_WIDTH; ++i) {
                    float sample = change * stepset[i];
                    error -= sample;
                    *dest++ += sample;
                }

                // split the error between the two centers, equally
                float halferror = error * 0.5f;
                if (center1 >= bufsize) {
                    // center is in wraparound
                    wraparound[center1 - bufsize] += halferror;
                } else {
                    mPeriodBuf[center1] += halferror;
                }
                if (center2 >= bufsize) {
                    // center is in wraparound
                    wraparound[center2 - bufsize] += halferror;
                } else {
                    mPeriodBuf[center2] += halferror;
                }

                // advance position to the next period
                position += spp;
            }
        }

        // add differences from start of period to wraparound
        for (size_t i = 0; i != STEP_WIDTH - 1; ++i) {
            wraparound[i] += mPeriodBuf[i];
        }


        // do the running sum

        float previous = mDeltaBuf[0].before;
        for (size_t i = 0; i != bufsize; ++i) {
            float cur = mPeriodBuf[i] + previous;
            mPeriodBuf[i] = cur;
            previous = cur;
        }

        // running sum the wraparound buffer, moving each sample to start of period
        for (size_t i = 0; i != STEP_WIDTH - 1; ++i) {
            float cur = wraparound[i] + previous;
            mPeriodBuf[i] = cur;
            previous = cur;
        }

        // OPTIONAL: shift by the period by STEP_CENTER so that transitions are
        //           centered at the time they occur.
        //
        //     /----      /----
        // ---/       ---/
        // ^              ^
        // before         after
    }
}

std::vector<float>& Osc::period() {
    return mPeriodBuf;
}

}